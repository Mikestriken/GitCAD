#!/bin/bash
echo "DEBUG: post-checkout hook trap-card triggered!" >&2
# ==============================================================================================
#                                         GIT LFS Hooks
# ==============================================================================================
command -v git-lfs >/dev/null 2>&1 || { echo >&2 "\nThis repository is configured for Git LFS but 'git-lfs' was not found on your path. If you no longer wish to use Git LFS, remove this hook by deleting the 'post-checkout' file in the hooks directory (set by 'core.hookspath'; usually '.git/hooks').\n"; exit 2; }

git lfs post-checkout "$@"
# ==============================================================================================
#                                 Verify and Retrieve Dependencies
# ==============================================================================================
# Ensure working dir is the root of the repo
# GIT_ROOT=$(git rev-parse --show-toplevel)
# cd "$GIT_ROOT"

# Import code used in this script
FUNCTIONS_FILE="FreeCAD_Automation/utils.sh"
source "$FUNCTIONS_FILE"

if [ -z "$PYTHON_PATH" ] || [ -z "$REQUIRE_LOCKS" ]; then
    echo "Config file missing or invalid; cannot proceed." >&2
    exit $FAIL
fi

# ==============================================================================================
#                                     Pull LFS files
# ==============================================================================================
git lfs pull
echo "DEBUG: Pulled lfs files" >&2

# ==============================================================================================
#                         Update .FCStd files with uncompressed files
# ==============================================================================================
# Note, Args: $1=old-head-sha $2=new-head-sha $3=checkout-type (1=branch, 0=file)
if [[ "$3" == "0" || "$3" == "1" ]]; then
    echo "DEBUG: Processing Checkout...." >&2

    # Branch checkout - process all tracked .FCStd files with change detection
    TRACKED_FCSTD_FILES=$(git ls-files | grep -i '\.fcstd$')
    echo -e "\nDEBUG: checking '$(echo $TRACKED_FCSTD_FILES | xargs)' for changes..." >&2

    for FCStd_file in $TRACKED_FCSTD_FILES; do
        echo -e "\nDEBUG: checking '$FCStd_file'...." >&2

        # Check if .FCStd file exists
        if [ ! -f "$FCStd_file" ]; then
            echo "Error: Could not find '$FCStd_file', skipping..." >&2
            continue
        fi

        # Get the uncompressed directory path for this .FCStd file
        FCStd_dir_path=$(get_FCStd_dir "$FCStd_file") || {
            echo "Error: Failed to get directory path for '$FCStd_file', skipping..." >&2
            continue
        }

        echo "DEBUG: Found dir '$FCStd_dir_path'" >&2

        # Check if directory has changes in the checkout
        DIR_HAS_CHANGES=$(dir_has_changes "$FCStd_dir_path" "$1" "$2") || {
            echo "Error: Failed to get dir changes for '$FCStd_dir_path', skipping..." >&2
            continue
        }

        if [ "$DIR_HAS_CHANGES" == "1" ]; then
            echo "DEBUG: Detected changes, reloading '$FCStd_file'...." >&2
            
            # Pull LFS data for the directory
            git lfs pull --include="$FCStd_dir_path/**"

            # Import data to FCStd file
            "$PYTHON_PATH" "$FCStdFileTool" --SILENT --CONFIG-FILE --import "$FCStd_file" || {
                echo "Error: Failed to import $FCStd_file, skipping..." >&2
                continue
            }
        fi

        if [ "$REQUIRE_LOCKS" == "1" ]; then
            # Check if user has valid lock
            FCSTD_FILE_HAS_VALID_LOCK=$(FCStd_file_has_valid_lock "$FCStd_file") || continue

            if [ "$FCSTD_FILE_HAS_VALID_LOCK" == "0" ]; then
                # User doesn't have lock, set .FCStd file to readonly
                make_readonly "$FCStd_file"
                echo "DEBUG: set '$FCStd_file' readonly." >&2
            else
                # User has lock, set .FCStd file to writable
                make_writable "$FCStd_file"
                echo "DEBUG: set '$FCStd_file' writable." >&2
            fi
        fi
    done

# elif [ "$3" == "0" ]; then
#     echo "DEBUG: Processing file Checkout...." >&2
#     # File checkout - check if it's a .FCStd file and handle accordingly
#     # For file checkouts, we need to determine which file was checked out
#     # This is more complex as git doesn't directly tell us which file was checked out
#     # For now, we'll process all .FCStd files but this could be optimized

#     TRACKED_FCSTD_FILES=$(git ls-files | grep -i '\.fcstd$')
#     echo -e "\nDEBUG: checking '$(echo $TRACKED_FCSTD_FILES | xargs)' for changes..." >&2
#     for FCStd_file in $TRACKED_FCSTD_FILES; do
#         echo -e "\nDEBUG: checking '$FCStd_file'...." >&2

#         # Check if .FCStd file exists and was recently modified (indicating checkout)
#         if [ ! -f "$FCStd_file" ]; then
#             continue
#         fi

#         # Get the uncompressed directory path for this .FCStd file
#         FCStd_dir_path=$(get_FCStd_dir "$FCStd_file") || {
#             echo "Error: Failed to get directory path for '$FCStd_file', skipping..." >&2
#             continue
#         }

#         echo "DEBUG: Found dir '$FCStd_dir_path'" >&2

#         # For file checkouts, we assume the directory was updated if the file exists
#         # Pull LFS data for the directory
#         git lfs pull --include="$FCStd_dir_path/**"

#         # Import data to FCStd file
#         "$PYTHON_PATH" "$FCStdFileTool" --SILENT --CONFIG-FILE --import "$FCStd_file" || {
#             echo "Error: Failed to import $FCStd_file, skipping..." >&2
#             continue
#         }

#         if [ "$REQUIRE_LOCKS" == "1" ]; then
#             # Check if user has valid lock
#             FCSTD_FILE_HAS_VALID_LOCK=$(FCStd_file_has_valid_lock "$FCStd_file") || continue

#             if [ "$FCSTD_FILE_HAS_VALID_LOCK" == "0" ]; then
#                 # User doesn't have lock, set .FCStd file to readonly
#                 make_readonly "$FCStd_file"
#                 echo "DEBUG: set '$FCStd_file' readonly." >&2
#             else
#                 # User has lock, set .FCStd file to writable
#                 make_writable "$FCStd_file"
#                 echo "DEBUG: set '$FCStd_file' writable." >&2
#             fi
#         fi
#     done

else
    # Unknown checkout type
    echo "Unknown checkout type: $3, skipping .FCStd processing..." >&2
fi

exit $SUCCESS