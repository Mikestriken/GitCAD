#!/bin/bash
echo "DEBUG: post-checkout hook trap-card triggered!" >&2
# ==============================================================================================
#                                         GIT LFS Hooks
# ==============================================================================================
command -v git-lfs >/dev/null 2>&1 || { echo >&2 "\nThis repository is configured for Git LFS but 'git-lfs' was not found on your path. If you no longer wish to use Git LFS, remove this hook by deleting the 'post-checkout' file in the hooks directory (set by 'core.hookspath'; usually '.git/hooks').\n"; exit 2; }

git lfs post-checkout "$@"
# ==============================================================================================
#                               Verify and Retrieve Dependencies
# ==============================================================================================
# Import code used in this script
FUNCTIONS_FILE="FreeCAD_Automation/utils.sh"
source "$FUNCTIONS_FILE"

if [ -z "$PYTHON_PATH" ] || [ -z "$REQUIRE_LOCKS" ]; then
    echo "Config file missing or invalid; cannot proceed." >&2
    exit $FAIL
fi

# ==============================================================================================
#                                      Pull LFS files
# ==============================================================================================
git lfs pull
echo "DEBUG: Pulled lfs files" >&2

# ==============================================================================================
#                                  Handle Rebase Edge-case
# ==============================================================================================
# Note: Rebase logic handled by Post-Rewrite hook. If rebase detected (rebase-merge or rebase-apply dirs exit in .git), skip post-commit hook logic
if [ -d "$(git rev-parse --git-path rebase-merge)" ] || [ -d "$(git rev-parse --git-path rebase-apply)" ]; then
    echo "DEBUG: Rebase detected, skipping post-checkout hook logic..." >&2
    exit $SUCCESS

# ==============================================================================================
#                                    Branch Checkout Logic
# ==============================================================================================
# Note, Args: $1=old-head-sha $2=new-head-sha $3=checkout-type (1=branch, 0=file)
elif [ "$3" == "1" ]; then
    echo "DEBUG: Processing Branch Checkout...." >&2

    if [ "$REQUIRE_LOCKS" == "$TRUE" ]; then
        CURRENT_USER=$(git config --get user.name) || {
            echo "Error: git config user.name not set!" >&2
            exit $FAIL
        }

        CURRENT_LOCKS=$(git lfs locks | awk '$2 == "'$CURRENT_USER'" {print $1}') || {
            echo "Error: failed to list of active lock info." >&2
            exit $FAIL
        }
    fi

    echo "DEBUG: diffing <remote sha1>='$1'..'$2'=<local sha1>" >&2
    changed_files=$(git diff-tree --no-commit-id --name-only -r "$1" "$2")

    # Get changed `.changefile`s
    changefiles_changed_between_commits=$(echo "$changed_files" | grep -i '\.changefile$')

    echo -e "\nDEBUG: checking changed changefiles: '$(echo $changefiles_changed_between_commits | xargs)'" >&2

    for changefile in $changefiles_changed_between_commits; do
        echo -e "\nDEBUG: checking '$changefile'....$(grep 'File Last Exported On:' "$changefile")" >&2

        FCStd_file_path=$(get_FCStd_file_from_changefile "$changefile") || continue

        echo -n "IMPORTING: '$FCStd_file_path'...." >&2
        
        # Import data to FCStd file
        "$PYTHON_EXEC" "$FCStdFileTool" --SILENT --CONFIG-FILE --import "$FCStd_file_path" || {
            echo "Error: Failed to import $FCStd_file_path, skipping..." >&2
            continue
        }
        
        echo "SUCCESS" >&2

        git fcmod "$FCStd_file_path"

        FCStd_dir_path=$(dirname $changefile)
        lockfile="$FCStd_dir_path/.lockfile"

        if [ "$REQUIRE_LOCKS" == "$TRUE" ]; then
            if echo "$CURRENT_LOCKS" | grep -q "$lockfile"; then
                # User has lock, set .FCStd file to writable
                make_writable "$FCStd_file_path"
                echo "DEBUG: set '$FCStd_file_path' writable." >&2
            else
                # User doesn't have lock, set .FCStd file to readonly
                make_readonly "$FCStd_file_path"
                echo "DEBUG: set '$FCStd_file_path' readonly." >&2
            fi
        fi
    done

# ==============================================================================================
#                                      File Checkout Logic
# ==============================================================================================
# Note, Args: $1=old-head-sha $2=new-head-sha $3=checkout-type (1=branch, 0=file)
# Note: GitCAD wapper logic is the same as fco alias logic in checkout-FCStd-files.sh.
    # The reason I don't simply call the alias is because the alias doesn't work with non-FCStd files.
    # This implementation will also work with non-FCStd files, it just tacs on FCStd checkout logic.
    
    # Even if non-FCStd file logic was implemented for git fco, the environments are different enough I don't mind having duplicate code.
elif [ "$3" == "0" ]; then
    echo "DEBUG: Processing File Checkout...." >&2
    
    # >>>>>>>>>>>>>>>>>>> Prevent Infinite Loop With GitCAD Activated <<<<<<<<<<<<<<<<<<<
    if [ -n "$FILE_CHECKOUT_IN_PROGRESS" ]; then
        echo "DEBUG: File checkout already in progress, skipping..." >&2
        :

    # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> If GitCAD Activated <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        # Check if GitCAD wrapper is active and has provided checkout info
            # Note 1: GIT_CHECKOUT_COMMIT, GIT_CHECKOUT_PATTERNS, CHANGEFILES_WITH_MODIFICATIONS_NOT_YET_COMMITTED defined in the `FreeCAD_Automation/git` wrapper
            # Note 2: GITCAD_ACTIVATED defined in the `FreeCAD_Automation/activate.sh` wrapper init script
    elif [ -n "$GITCAD_ACTIVATED" ] && [ -n "$GIT_CHECKOUT_COMMIT" ] && [ -n "$GIT_CHECKOUT_PATTERNS" ]; then
        echo "DEBUG: Processing file checkout with commit=$GIT_CHECKOUT_COMMIT patterns=$GIT_CHECKOUT_PATTERNS" >&2
        
        IFS=' ' read -ra CHECKOUT_PATTERNS <<< "$GIT_CHECKOUT_PATTERNS" # Convert space-separated string back to array
        
        # Determine if this is a HEAD checkout based on whether we received modified changefiles from wrapper
        IS_HEAD_CHECKOUT=$FALSE
        if [ -n "$CHANGEFILES_WITH_MODIFICATIONS_NOT_YET_COMMITTED" ]; then
            IS_HEAD_CHECKOUT=$TRUE
            echo "DEBUG: HEAD checkout detected (received modified changefiles from wrapper)" >&2
            echo "DEBUG: Modified changefiles: $(echo $CHANGEFILES_WITH_MODIFICATIONS_NOT_YET_COMMITTED | xargs)" >&2
        fi
        
        if [ "$REQUIRE_LOCKS" == "$TRUE" ]; then
            CURRENT_USER=$(git config --get user.name) || {
                echo "Error: git config user.name not set!" >&2
                exit $FAIL
            }
            
            CURRENT_LOCKS=$(git lfs locks | awk '$2 == "'$CURRENT_USER'" {print $1}') || {
                echo "Error: failed to list of active lock info." >&2
                exit $FAIL
            }
        fi
        
        MATCHED_FCStd_file_paths=()
        for pattern in "${CHECKOUT_PATTERNS[@]}"; do
            echo "DEBUG: Matching pattern: '$pattern'...." >&2
            
            if [[ -d "$pattern" || "$pattern" == *"*"* || "$pattern" == *"?"* ]]; then
                echo "DEBUG: Pattern contains wildcards or is a directory" >&2
                while IFS= read -r file; do
                    if [[ "$file" =~ \.[fF][cC][sS][tT][dD]$ ]]; then
                        MATCHED_FCStd_file_paths+=("$file")
                    fi
                done < <(git ls-files "$pattern")
                
            elif [[ "$pattern" =~ \.[fF][cC][sS][tT][dD]$ ]]; then
                echo "DEBUG: Pattern is an FCStd file" >&2
                MATCHED_FCStd_file_paths+=("$pattern")
            else
                echo "DEBUG: Pattern '$pattern' is not an FCStd file, directory, or wildcard..... skipping" >&2
            fi
        done
        
        MATCHED_FCStd_file_paths=($(printf '%s\n' "${MATCHED_FCStd_file_paths[@]}" | sort -u)) # Remove duplicates
        
        echo "DEBUG: matched FCStd files: ${MATCHED_FCStd_file_paths[*]}" >&2
        
        if [ ${#MATCHED_FCStd_file_paths[@]} -eq 0 ]; then
            echo "DEBUG: No FCStd files matched the patterns" >&2
            exit $SUCCESS
        fi
        
        # For every FCStd_file_path matched with patterns, check if the corresponding FCStd_dir_path will change between commits
            # We'll only checkout dirs for files that will actually change between commits OR if it's currently modified (HEAD checkout case).
        FCStd_dirs_to_checkout=()
        declare -A FCStd_dir_to_file_dict # Bash Dictionary
        changefiles_changed_between_commits=$(git diff-tree --no-commit-id --name-only -r "$GIT_CHECKOUT_COMMIT" HEAD | grep -i '\.changefile$')
        
        for FCStd_file_path in "${MATCHED_FCStd_file_paths[@]}"; do
            echo "DEBUG: Processing FCStd file: $FCStd_file_path" >&2
            
            FCStd_dir_path=$(get_FCStd_dir "$FCStd_file_path") || continue
            changefile_path="$FCStd_dir_path/.changefile"
            
            if echo "$changefiles_changed_between_commits" | grep -q "^$changefile_path$" || echo "$CHANGEFILES_WITH_MODIFICATIONS_NOT_YET_COMMITTED" | grep -q "^$changefile_path$"; then
                FCStd_dir_to_file_dict["$FCStd_dir_path"]="$FCStd_file_path"
                FCStd_dirs_to_checkout+=("$FCStd_dir_path")
                echo "DEBUG: Added '$FCStd_dir_path' to checkout list (changefile has changes or is modified)" >&2
            else
                echo "DEBUG: Skipping '$FCStd_dir_path' (no changefile changes between $GIT_CHECKOUT_COMMIT and HEAD, and not modified)" >&2
            fi
        done
        
        FCStd_dirs_to_checkout=($(printf '%s\n' "${FCStd_dirs_to_checkout[@]}" | sort -u)) # Remove duplicates from FCStd_dirs_to_checkout
        
        if [ ${#FCStd_dirs_to_checkout[@]} -eq 0 ]; then
            echo "DEBUG: No FCStd files with changefile changes to checkout" >&2
            exit $SUCCESS
        fi
        
        echo "DEBUG: Checking out dirs from commit '$GIT_CHECKOUT_COMMIT': ${FCStd_dirs_to_checkout[*]}" >&2
        
        # Note: `FILE_CHECKOUT_IN_PROGRESS=$TRUE` Prevents infinite loop and suppresses GitCAD activation warning message
        FILE_CHECKOUT_IN_PROGRESS=$TRUE git checkout "$GIT_CHECKOUT_COMMIT" -- "${FCStd_dirs_to_checkout[@]}" > /dev/null 2>&1  || {
            echo "Error: Failed to checkout dirs from commit '$GIT_CHECKOUT_COMMIT'" >&2
            exit $FAIL
        }
        
        # Import data from checked out FCStd dirs into their FCStd files
        for FCStd_dir_path in "${FCStd_dirs_to_checkout[@]}"; do
            FCStd_file_path="${FCStd_dir_to_file_dict[$FCStd_dir_path]}"
            echo -n "IMPORTING: '$FCStd_file_path'...." >&2
            
            # Import data to FCStd file
            "$PYTHON_EXEC" "$FCStdFileTool" --SILENT --CONFIG-FILE --import "$FCStd_file_path" || {
                echo "Error: Failed to import $FCStd_file_path, skipping..." >&2
                continue
            }
            
            echo "SUCCESS" >&2
            
            # Only clear modification flag when checking out HEAD (resetting modified files)
            if [ "$IS_HEAD_CHECKOUT" == "$TRUE" ]; then
                git fcmod "$FCStd_file_path"
                echo "DEBUG: Cleared modification flag for '$FCStd_file_path' (HEAD checkout)" >&2
            fi
            
            # Handle locks
            if [ "$REQUIRE_LOCKS" == "$TRUE" ]; then
                FCSTD_FILE_HAS_VALID_LOCK=$(FCStd_file_has_valid_lock "$FCStd_file_path") || continue
                
                if [ "$FCSTD_FILE_HAS_VALID_LOCK" == "$FALSE" ]; then
                    # User doesn't have lock, set .FCStd file to readonly
                    make_readonly "$FCStd_file_path"
                    echo "DEBUG: Set '$FCStd_file_path' readonly." >&2
                else
                    # User has lock, set .FCStd file to writable
                    make_writable "$FCStd_file_path"
                    echo "DEBUG: Set '$FCStd_file_path' writable." >&2
                fi
            fi
        done
    
    # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> If GitCAD NOT Activated <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    else
        # GitCAD not activated or no checkout info available
        echo "WARNING: File checkout detected, for .FCStd files either activate GitCAD and try again or use \`git fco\` instead!" >&2
    fi

# ==============================================================================================
#                                      Other Checkout Type
# ==============================================================================================
else
    # Unknown checkout type
    echo "Unknown checkout type: $3, skipping \`.FCStd\` processing..." >&2
fi

exit $SUCCESS