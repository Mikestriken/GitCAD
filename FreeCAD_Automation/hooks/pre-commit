#!/bin/bash
# echo "DEBUG: ============== pre-commit hook trap-card triggered! ==============" >&2
# ==============================================================================================
#                                 Verify and Retrieve Dependencies
# ==============================================================================================
# Import code used in this script
FUNCTIONS_FILE="FreeCAD_Automation/utils.sh"
source "$FUNCTIONS_FILE"

# ==============================================================================================
#                      Prevent non-empty .FCStd files from being committed
# ==============================================================================================
# Get staged `.FCStd` files
# Diff Filter => (A)dded / (C)opied / (D)eleted / (M)odified / (R)enamed / (T)ype changed / (U)nmerged / (X) unknown / (B)roken pairing
# Note: Excluding (A)dded because newly added .FCStd files ARE empty, we're checking that the .FCStd files don't get modified past this point.... at least that is what I think I was intending...
GIT_COMMAND="update-index" git update-index --refresh -q >/dev/null 2>&1
STAGED_FCSTD_FILES="$(GIT_COMMAND="diff-index" git diff-index --cached --name-only --diff-filter=CDMRTUXB HEAD | grep -i -- '\.fcstd$')"
# echo -e "\nDEBUG: checking staged FCStd files: '$(echo "$STAGED_FCSTD_FILES" | xargs)'" >&2

mapfile -t STAGED_FCSTD_FILES <<<"$STAGED_FCSTD_FILES"
for FCStd_file_path in "${STAGED_FCSTD_FILES[@]}"; do
    [ -z "$FCStd_file_path" ] && continue

    # echo -e "\nDEBUG: checking '$FCStd_file_path'...." >&2

    if [ -s "$FCStd_file_path" ]; then
        echo "Error: $FCStd_file_path is not empty, export it using \`git fadd\` (\`git add\` with GitCAD activated) or clear it using \`git fcmod\`" >&2
        exit $FAIL
    fi
done

# ==============================================================================================
#                         Check if user allowed to modify .FCStd files
# ==============================================================================================
if [ "$REQUIRE_LOCKS" = "$TRUE" ]; then
    CURRENT_USER="$(GIT_COMMAND="config" git config --get user.name)" || {
        echo "Error: git config user.name not set!" >&2
        exit $FAIL
    }

    mapfile -t CURRENT_LOCKS < <(
        GIT_COMMAND="lfs" git lfs locks |
        awk -v user="$CURRENT_USER" '
            match($0, /^(.*)[[:space:]]+([^[:space:]]+)[[:space:]]+ID:[0-9]+$/, m) &&
            m[2] == user {
                gsub(/[[:space:]]+$/, "", m[1])
                print m[1]
            }
        '
    ) || {
        echo "Error: failed to list of active lock info." >&2
        exit $FAIL
    }

    # Get staged `.changefile`s
    # Diff Filter => (A)dded / (C)opied / (D)eleted / (M)odified / (R)enamed / (T)ype changed / (U)nmerged / (X) unknown / (B)roken pairing
    GIT_COMMAND="update-index" git update-index --refresh -q >/dev/null 2>&1
    STAGED_CHANGEFILES="$(GIT_COMMAND="diff-index" git diff-index --cached --name-only --diff-filter=CDMRTUXB HEAD | grep -i -- '\.changefile$')"
    # echo -e "\nDEBUG: checking staged changefiles: '$(echo "$STAGED_CHANGEFILES" | xargs)'" >&2

    mapfile -t STAGED_CHANGEFILES <<<"$STAGED_CHANGEFILES"
    for changefile in "${STAGED_CHANGEFILES[@]}"; do
        [ -z "$changefile" ] && continue
        
        # echo -e "\nDEBUG: checking '$changefile'....$(grep 'File Last Exported On:' "$changefile")" >&2

        FCStd_dir_path="$(dirname "$changefile")"
        lockfile="$FCStd_dir_path/.lockfile"

        if printf '%s\n' "${CURRENT_LOCKS[@]}" | grep -Fxq -- "$lockfile"; then
            # echo "DEBUG: valid lock found for '$lockfile'" >&2
            :
        else
            echo "Error: User doesn't have lock for '$lockfile'... Aborting commit operation..." >&2
            exit $FAIL
        fi
    done
fi

exit $SUCCESS