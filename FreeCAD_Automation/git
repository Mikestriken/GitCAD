#!/bin/bash
# ==============================================================================================
#                                       Script Overview
# ==============================================================================================
# Temporary git wrapper for GitCAD workflow. Only wraps over git.exe when user runs `source activate.sh` for that terminal session

# ==============================================================================================
#                              Verify and Retrieve Dependencies
# ==============================================================================================
if [ -z "$REAL_GIT" ]; then
  echo "Error: Could not find real git executable" >&2
  exit 1 # 1=$FAIL
fi

# ==============================================================================================
#                     Call Real `git.exe` With GIT_COMMAND Environment Variable
# ==============================================================================================
case $1 in
  # Note: Unfortunately I cannot pass args directly to post-checkout hook directly. For this reason...
  # ToDo: Consider removing GitCAD post-checkout logic and redirecting the call to fco alias...
  "checkout")
    shift
    
    # Get GIT_PREFIX (subdir the user is CDed into)
    GIT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null) || {
      echo "Error: Current Directory is not a git repository" >&2
      exit 1 # 1=$FAIL
    }
    
    CURRENT_DIR=$(pwd)
    if [ "$CURRENT_DIR" = "$GIT_ROOT" ]; then
      GIT_PREFIX=""
    else
      GIT_PREFIX="${CURRENT_DIR#$GIT_ROOT/}/" # Remove `$GIT_ROOT/` from start of $CURRENT_DIR
    fi
    
    # Parse arguments to find COMMIT_TO_CHECKOUT and files
    # Supports: git checkout COMMIT_TO_CHECKOUT -- FILE [FILE ...]
    #       or: git checkout COMMIT_TO_CHECKOUT FILE [FILE ...]
    COMMIT_TO_CHECKOUT=""
    FILES=()
    FOUND_SEPARATOR=false

    for arg in "$@"; do
      # Skip file separator --
      if [ "$arg" = "--" ]; then
        FOUND_SEPARATOR=true
        continue
      fi
      
      # First Arg (COMMIT_TO_CHECKOUT)
      if [ -z "$COMMIT_TO_CHECKOUT" ] && [ "$FOUND_SEPARATOR" = false ]; then
        COMMIT_TO_CHECKOUT="$arg"
      
      # Subsequent Args (FILES)
      elif [ -n "$COMMIT_TO_CHECKOUT" ]; then
        if [ "$arg" = "." ]; then # Special case: '.' means current directory user is CDed into
          FILES+=("$GIT_PREFIX")
        
        # Prefix subdir user is CDed into
        else
          FILES+=("${GIT_PREFIX}${arg}")
        fi
      fi
    done

    # If file checkout detected
    if [ -n "$COMMIT_TO_CHECKOUT" ] && [ ${#FILES[@]} -gt 0 ]; then
      # If checking out HEAD (resetting modified files)
        # We also need to check if the FCStd_dir_path or FCStd_file_path is modified in the working directory PRIOR to checkout
      HEAD_SHA=$(git rev-parse HEAD)
      CHECKOUT_SHA=$(git rev-parse "$COMMIT_TO_CHECKOUT")
      IS_HEAD_CHECKOUT=$FALSE
      CHANGEFILES_WITH_MODIFICATIONS_NOT_YET_COMMITTED=""
      
      if [ "$HEAD_SHA" = "$CHECKOUT_SHA" ]; then
        echo "DEBUG: Detected HEAD checkout (resetting modified files)" >&2
        
        IS_HEAD_CHECKOUT=$TRUE
        git update-index --refresh -q >/dev/null 2>&1

        CHANGEFILES_WITH_MODIFICATIONS_NOT_YET_COMMITTED=$(git diff-index --name-only HEAD | grep -i '\.changefile$')
        
        FCStd_files_with_modifications_not_yet_committed=$(git diff-index --name-only HEAD | grep -i '\.fcstd$')
        
        for FCStd_file_path in $FCStd_files_with_modifications_not_yet_committed; do
          FCStd_dir_path=$(get_FCStd_dir "$FCStd_file_path") || continue
          changefile_path="$FCStd_dir_path/.changefile"

          if echo "$CHANGEFILES_WITH_MODIFICATIONS_NOT_YET_COMMITTED" | grep -Fxq "$changefile_path"; then
            continue
          else
            CHANGEFILES_WITH_MODIFICATIONS_NOT_YET_COMMITTED="$CHANGEFILES_WITH_MODIFICATIONS_NOT_YET_COMMITTED"$'\n'"$changefile_path"
          fi
        done

        echo "DEBUG: Found modified changefiles for HEAD checkout: $(echo $CHANGEFILES_WITH_MODIFICATIONS_NOT_YET_COMMITTED | xargs)" >&2
      fi
        
      GIT_COMMAND="checkout" GIT_CHECKOUT_COMMIT="$COMMIT_TO_CHECKOUT" GIT_CHECKOUT_PATTERNS="${FILES[*]}" CHANGEFILES_WITH_MODIFICATIONS_NOT_YET_COMMITTED="$CHANGEFILES_WITH_MODIFICATIONS_NOT_YET_COMMITTED" "$REAL_GIT" checkout "$@"
    else
      GIT_COMMAND="checkout" "$REAL_GIT" checkout "$@"
    fi
    
    ;;
  "reset")
    shift
    GIT_COMMAND=$1 bash FreeCAD_Automation/git_aliases/git-reset-and-sync-FCStd-files.sh "$@"
    ;;
  "stash")
    shift
    
    # # Get GIT_PREFIX (subdir the user is CDed into)
    # GIT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null) || {
    #   echo "Error: Current Directory is not a git repository" >&2
    #   exit 1 # 1=$FAIL
    # }
    
    # CURRENT_DIR=$(pwd)
    # if [ "$CURRENT_DIR" = "$GIT_ROOT" ]; then
    #   GIT_PREFIX=""
    # else
    #   GIT_PREFIX="${CURRENT_DIR#$GIT_ROOT/}/" # Remove `$GIT_ROOT/` from start of $CURRENT_DIR
    # fi
    
    # # Call stash alias script directly
    # GIT_COMMAND=$1 bash FreeCAD_Automation/git_aliases/git-stash-and-sync-FCStd-files.sh "$GIT_PREFIX" "$@"
    
    GIT_COMMAND=$1 "$REAL_GIT" fstash "$@"
    ;;
  *)
    GIT_COMMAND=$1 "$REAL_GIT" "$@"
    ;;
esac

exit $?