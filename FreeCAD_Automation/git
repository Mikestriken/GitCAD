#!/bin/bash
# ==============================================================================================
#                                       Script Overview
# ==============================================================================================
# Temporary git wrapper for GitCAD workflow. Only wraps over git.exe when user runs `source activate.sh` for that terminal session
# ==============================================================================================
#                                       Constant Globals
# ==============================================================================================
SUCCESS=0
FAIL=1
TRUE=0
FALSE=1

# ==============================================================================================
#                              Verify and Retrieve Dependencies
# ==============================================================================================
if [ -z "$REAL_GIT" ]; then
  echo "Error: Could not find real git executable" >&2
  exit $FAIL
fi

if [ "$REAL_GIT" = "$0" ]; then
  echo "Error, infinite recursion detected: activate.sh or something else set REAL_GIT environment variable to this wrapper script instead of the real git executable." >&2
  exit $FAIL
fi

# ==============================================================================================
#                     Call Real `git.exe` With GIT_COMMAND Environment Variable
# ==============================================================================================
case $1 in
  "checkout")
    shift

    checkout_args=("$@")
    
    # Parse arguments to determine checkout type
    # File Checkout:
    #           git checkout COMMIT_TO_CHECKOUT -- FILE [FILE ...]
    #           git checkout COMMIT_TO_CHECKOUT FILE [FILE ...]
    # Branch Checkout:
    #           git checkout COMMIT_TO_CHECKOUT
    #           git checkout -b COMMIT_TO_CHECKOUT
    COMMIT_TO_CHECKOUT=""
    parsed_file_path_args=()
    IS_FILE_CHECKOUT=$FALSE
    while [ $# -gt 0 ]; do
      # echo "DEBUG: parsing '$1'..." >&2
      case $1 in
        -*)
          # echo "DEBUG: '$1' flag is not recognized, skipping..." >&2
          :
          ;;
        
        *)
          # First Arg that doesn't start with '-' should be COMMIT_TO_CHECKOUT
          if [ -z "$COMMIT_TO_CHECKOUT" ]; then
            COMMIT_TO_CHECKOUT="$1"
            # echo "DEBUG: Commit to Checkout='$COMMIT_TO_CHECKOUT'" >&2

          # Assume subsequent args are file paths (if not staring with '-') => Confirming this is a file checkout type.
          else
            # echo "DEBUG: Checkout type is file checkout" >&2
            IS_FILE_CHECKOUT=$TRUE
            break
          fi
          ;;
          
      esac
      shift
    done
    
    if [ "$IS_FILE_CHECKOUT" = "$TRUE" ]; then
      # echo "DEBUG: calling 'GIT_COMMAND=\"checkout\" \"$REAL_GIT\" fco \"${checkout_args[@]}\"'" >&2
      exec env GIT_COMMAND="checkout" "$REAL_GIT" fco "${checkout_args[@]}"
    else
      # echo "DEBUG: calling 'GIT_COMMAND=\"checkout\" \"$REAL_GIT\" checkout \"${checkout_args[@]}\"'" >&2
      exec env GIT_COMMAND="checkout" "$REAL_GIT" checkout "${checkout_args[@]}"
    fi
    ;;

  "reset")
    shift
    # echo "DEBUG: calling 'GIT_COMMAND=\"reset\" \"$REAL_GIT\" freset \"$@\"'" >&2
    exec env GIT_COMMAND="reset" "$REAL_GIT" freset "$@"
    ;;

  "stash")
    shift
    # echo "DEBUG: calling 'GIT_COMMAND=\"stash\" \"$REAL_GIT\" fstash \"$@\"'" >&2
    exec env GIT_COMMAND="stash" "$REAL_GIT" fstash "$@"
    ;;

  *)
    # echo "DEBUG: calling 'GIT_COMMAND=\"$1\" \"$REAL_GIT\" \"$@\"'" >&2
    exec env GIT_COMMAND="$1" "$REAL_GIT" "$@"
    ;;

esac